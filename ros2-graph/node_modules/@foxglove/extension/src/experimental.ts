/* eslint-disable @typescript-eslint/no-namespace */

import { Immutable } from "@foxglove/extension/src/immutable";
import {
  ExtensionContext as BaseExtensionContext,
  RegisterMessageConverterArgs as LegacyRegisterMessageConverterArgs,
  MessageEvent,
} from "@foxglove/extension/src/stable";

export type MessageSchemaField = "string" | "number" | "bool" | "byte";

/**
 * Describes the structure of a message with field names and their types.
 *
 * @example
 * ```typescript
 * {
 *   // Primitive fields
 *   position: "number",
 *   name: "string",
 *   active: "bool",
 *   singleByte: "byte",
 *
 *   // Arrays of primitive types
 *   coordinates: ["number"],
 *   labels: ["string"],
 *   flags: ["bool"],
 *   rawData: ["byte"],
 *
 *   // Nested objects
 *   metadata: {
 *     timestamp: "number",
 *     source: "string"
 *   },
 *
 *   // Arrays of objects
 *   points: [{
 *     x: "number",
 *     y: "number",
 *     z: "number"
 *   }]
 * }
 * ```
 */
export type MessageSchemaDescription = {
  [key: string]:
    | MessageSchemaField
    | MessageSchemaDescription
    | [MessageSchemaField | MessageSchemaDescription];
};

/**
 * The experimental namespace contains experimental APIs that are not yet stable and WILL change or
 * be REMOVED at any time.
 *
 * These APIS are provided for isolated testing and feedback.You should avoid shipping org
 * extensions which depend on them because they WILL break in different versions of Foxglove and
 * can be CHANGED or REMOVED at any time.
 *
 * @hidden
 */
export namespace Experimental {
  type TopicConverterReturnType = (messageEvent: Immutable<MessageEvent>) => unknown;
  /**
   * This type represents the arguments you pass to
   * {@link ExtensionContext.registerMessageConverter} when you want to register a topic message
   * converter.
   *
   * @category Message converters
   */
  export type RegisterMessageConverterArgsTopic = {
    type: "topic";
    inputTopics: string[];
    outputTopic: string;
    schemaName: string;
    /**
     * Describes the structure of the output messages produced by this converter.
     *
     * This optional field allows Foxglove to understand the structure of your messages, enabling
     * features like autocompletion for message path selection.
     *
     * The schema can include:
     * - Primitive types: "string", "number", "bool", "byte"
     * - Arrays of primitives: ["string"], ["number"], ["bool"], ["byte"]
     * - Nested objects with their own field definitions
     * - Arrays of objects (each element having the same structure)
     *
     * @example
     * ```
     * schemaDescription: {
     *   // Simple fields
     *   timestamp: "number",
     *   label: "string",
     *   enabled: "bool",
     *   flags: "byte",
     *
     *   // Array of primitives
     *   values: ["number"],
     *   names: ["string"],
     *   options: ["bool"],
     *   data: ["byte"],
     *
     *   // Nested object
     *   position: {
     *     x: "number",
     *     y: "number",
     *     z: "number"
     *   },
     *
     *   // Array of objects
     *   landmarks: [{
     *     id: "string",
     *     position: {
     *       x: "number",
     *       y: "number"
     *     }
     *   }]
     * }
     * ```
     */
    schemaDescription?: MessageSchemaDescription;
    create: () => TopicConverterReturnType;
  };

  /**
   * This type represents the arguments you pass to
   * {@link ExtensionContext.registerMessageConverter} when you want to register a schema message
   * converter.
   *
   * `schema` converters allow you to leverage Foxglove's built-in visualization panels by
   * transforming messages to adhere to Foxglove-supported schemas â€” for example, you can convert
   * your custom GPS messages to
   * [`foxglove.LocationFix`](https://docs.foxglove.dev/docs/visualization/message-schemas/location-fix)
   * messages for visualization in the [Map
   * panel](https://docs.foxglove.dev/docs/visualization/panels/map).
   *
   * See the [Creating a message
   * converter](https://docs.foxglove.dev/docs/visualization/extensions/guides/create-message-converter)
   * guide for more details.
   *
   * @category Message converters
   */
  export type RegisterMessageConverterArgsSchema<Src = unknown> = {
    type: "schema";

    /** The source message schema name. This is the schema name of the original message. */
    fromSchemaName: string;

    /**
     * The converted message schema name. This is the schema name of the message you will output
     * from the converter.
     */
    toSchemaName: string;

    /**
     * A function which takes the original message and returns the converted message.
     *
     * If the function returns `undefined`, the output is ignored, and no message is provided to the
     * panel. This is useful if you want to selectively output converted messages depending on the
     * input messages' contents.
     */
    converter: (msg: Src, event: Immutable<MessageEvent<Src>>) => unknown;
  };

  export type RegisterMessageConverterArgs =
    | LegacyRegisterMessageConverterArgs
    | RegisterMessageConverterArgsSchema
    | RegisterMessageConverterArgsTopic;

  export interface ExtensionContext extends BaseExtensionContext {
    /**
     * `registerMessageConverter` registers converters to transform message data within Foxglove.
     *
     * You can register two kinds of converters: `schema` and `topic`.
     *
     * `schema` converters transform messages of one schema into another. Most often this is used to
     * turn messages using a custom or proprietary schema into a well-known Foxglove schema for
     * visualization in one of the built-in panels. `schema` converters allow a built-in panel which
     * requires well-known messages to natively support visualizing any topic for which there is a
     * schema converter registered. An example is converting an `acme.Gps` message to
     * `foxglove.LocationFix` to visualize any topics which publish `acme.Gps` messages in the
     * built-in map panel.
     *
     * See: {@link RegisterMessageConverterArgsSchema}.
     *
     * `topic` converters transform messages from one-or-more input topics to a new in-app topic.
     * Topic converters are more flexible than schema converters but require more logic and
     * decisions to implement. They can transform existing data into new topics for plotting,
     * inspecting, and visualizing. Topic converters can combine data from several input topics,
     * maintain state, and create messages from these multiple topics. They can also do the opposite
     * - take a single topic and turn it into multiple output topics.
     *
     * See: {@link RegisterMessageConverterArgsTopic}.
     */
    registerMessageConverter(args: RegisterMessageConverterArgs): void;
    /**
     * @deprecated Use `registerMessageConverter` with `type: "schema"` or `type: "topic"` instead.
     */
    registerMessageConverter<Src>(args: LegacyRegisterMessageConverterArgs<Src>): void;
    /**
     * Register a schema message converter.
     *
     * See: {@link RegisterMessageConverterArgsSchema}.
     */
    registerMessageConverter<Src>(args: RegisterMessageConverterArgsSchema<Src>): void;
    /**
     * Register a topic message converter.
     *
     * See: {@link RegisterMessageConverterArgsTopic}.
     */
    registerMessageConverter(args: RegisterMessageConverterArgsTopic): void;
  }

  export interface ExtensionModule {
    /**
     * This function will be called when your extension is loaded. In this function, you can register
     * your custom panels or other types of extension features.
     */
    activate: ExtensionActivate;
  }

  export type ExtensionActivate = (extensionContext: ExtensionContext) => void;
}
